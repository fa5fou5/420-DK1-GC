{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# TP 4 : récursion\n",
    "\n",
    "Dans ce TP :\n",
    "\n",
    "1. Principe des fonctions récursives\n",
    "2. Etude de cas : nombres de Stirling et dictionnaires\n",
    "   \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1 - La récursion"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Principes des fonctions récursives"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Quand on a défini une nouvelle fonction `f`, on peut l'appeler à tout moment -- Python remplace `f(x)` par le code que nous avons donné dans la définition. Une chose qui peut paraître étonnante au début, c'est qu'on peut appeler `f` au sein même de sa définition. Voici l'exemple que l'on donne toujours.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def factorielle(n):\n",
    "    \"\"\"Calcule n!= n(n-1)(n-2)...3*2*1.\"\"\"\n",
    "    \n",
    "    if n <= 1:\n",
    "        return 1\n",
    "    else:\n",
    "        return n*factorielle(n-1)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "factorielle(1000)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Mathématiquement, on peut passer beaucoup de temps à se demander si utiliser $f$ pendant qu'on est en train de définir $f$ a vraiment un sens. En informatique, tout est beaucoup plus simple : quand Python voit un appel à `f` dans la définition de `f`, tout simplement, *il y va*. L'observateur humain dit alors que `f` est une fonction \"récursive\", mais pour Python, c'est juste une fonction, qui se trouve par hasard faire un appel à elle-même.\n",
    "\n",
    "(Ceci est un petit mensonge ; les gens qui ont inventé le langage Python, et qui continuent de le faire évoluer, ont très certainement mis en place divers mécanismes pour optimiser l'exécution des fonctions récursives. Mais en principe, il n'y aurait pas vraiment besoin.)\n",
    "\n",
    "Le prix à payer est que Python nous autorise à écrire des choses aux conséquences catastrophiques : remplacez la fin de la définition par `n*factorielle(n+1)` et l'ordinateur va tourner sans fin jusqu'à épuisement de la mémoire!\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Pour s'entraîner à écrire une fonction récursive, voici maintenant l'exercice que l'on donne toujours.\n",
    "\n",
    ">**Exercice (Fibonacci)** Ecrire une fonction `fibonacci(n)` qui renvoie le terme $u_n$ de la suite définie par\n",
    ">\n",
    "> $ u_0 = u_1 = 1, \\qquad\\qquad$    $u_{n} = u_{n-1} + u_{n-2}$ pour $n\\ge 2$.\n",
    ">\n",
    "> Examiner le quotient $\\frac{u_{n+1}} {u_n}$ à mesure que $n$ augmente.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Un exemple très classique est l'algorithme d'Euclide pour calculer les pgcd. Vous l'avez déjà vu, mais rappelons qu'il se base sur la remarque simple suivante : si on écrit la division euclidienne\n",
    "\n",
    "$a= bq + r$\n",
    "\n",
    "de $a$ par $b\\ne 0$, alors $pgcd(a,b) = pgcd(b,r)$. Et aussi, $pgcd(a,0) = a$.\n",
    "\n",
    "La traduction en Python est immédiate :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def pgcd(a,b):\n",
    "    if b == 0:\n",
    "        return a\n",
    "    else:\n",
    "        r= a % b\n",
    "        return pgcd(b,r)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pgcd(24, 15)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">**Exercice (Bézout)** Ecrire une fonction `bezout(a,b)` qui renvoie une liste `[d, u, v]` où $d$ est le pgcd des entiers $a$ et $b$, et les entiers $u$ et $v$ vérifient $au +bv = d$.\n",
    ">\n",
    ">**Indication.** Faire d'abord une fonction auxiliaire, disons `bezout_aux(A,B,uA,vA,uB,vB)` qui prend en entrée six entiers, avec la propriété que $A= a u_A + bv_A$ et de même $B= a u_B + b v_B$, et qui renvoie `[d, u, v]`, où $d= pgcd(A,B)$ et $d = au + bv$. On fait ça de manière récursive, en commençant par \"si $B=0$ c'est évident, et sinon...\".\n",
    ">\n",
    ">Ensuite `bezout(a, b) = bezout_aux(a,b,1,0,0,1)`. A noter que `bezout_aux` ne prend pas $a$ et $b$ comme paramètre, il se trouve (un peu par hasard) qu'elle n'en a pas besoin.\n",
    ">\n",
    "> Facultatif : pourriez-vous ajouter des `print` bien sentis pour que l'on ait l'impression de lire la copie de quelqu'un qui ferait ce calcul \"à la main\" ? \n",
    "\n",
    "Exercice supplémentaire :\n",
    "\n",
    ">**Exercice (les défauts de la factorielle)** Vérifier que la fonction factorielle ci-dessus \"plante\" pour des valeurs de $n$ trop grandes (avec un $n \\le 10000$ ça devrait déjà arriver). A moins que vous n'ayez essayé des valeurs de $n$ vraiment délirantes, le plantage n'est pas dû à un manque de mémoire ; vous avez plutôt :\n",
    ">\n",
    "`RecursionError: maximum recursion depth exceeded in comparison`\n",
    ">\n",
    "> Il y a en effet une limite au nombre de fois qu'une fonction peut s'appeler elle-même avant de terminer. (Dans d'autres langages que Python, on peut contourner cette limite, au prix d'une petite ré-écriture de la fonction, voir \"tail-recursion\" sur Wikipedia; mais en Python, comme dans beaucoup de langages, c'est impossible.) Cette limite est tout de même très élevée, et en pratique ça ne dérange pas trop.\n",
    ">\n",
    "> Ceci dit, dans cet exercice on vous demande d'écrire une version de `factorielle` sans récursion (avec une boucle), et de comparer la vitesse et les plantages.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2 - Une étude de cas : nombres de Stirling et dictionnaires"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Les *nombres de Stirling de première espèce* sont par définitions les entiers $s(n,k)$ définis par l'identité polynomiale :\n",
    "\n",
    "$x(x-1)(x-2)\\cdots (x-n+1) = \\sum_{k=0}^n s(n,k) x^k$.\n",
    "\n",
    "Autrement dit: par définition $s(n,k)$ est le coefficient de $x^k$ quand on développe le polynôme donné par le membre de gauche de cette équation. Mais nous n'allons pas nous servir de cette définition pour faire les calculs.\n",
    "\n",
    "En effet, on peut montrer que $s(n,k) = (-1)^{n-k} c(n,k)$ où $c(n,k)$ est positif, et surtout vérifie les identités suivantes :\n",
    "\n",
    " * $c(0,0) = 1$,\n",
    " * $c(n,0)=0$ pour $n>0, \\quad$       $c(0,k)=0$ for $k>0$,\n",
    " * $c(n+1,k) = n c(n,k) + c(n,k-1)$.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">**Exercice (Stirling 1)** Ecrire une fonction récursive `stirling(n,k)` qui calcule $c(n,k)$ à partir des formules ci-dessus. Puis, étudier ses limitations : problèmes éventuels avec les grandes valeurs de $n$ et $k$, vitesse."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Un problème évident avec cette façon de faire est qu'on va répéter le calcul de certains $c(n,k)$ : par exemple pour calculer $c(4,4)$, on va calculer $c(4,3)$ et $c(3,4)$, et chacun de ces calculs va devoir trouver $c(3,3)$...\n",
    "\n",
    "On va améliorer un peu les choses à l'aide d'un *dictionnaire*. C'est un objet Python qui peut en contenir d'autres, un peu comme une liste ; la différence, c'est que si `L` est une liste de longueur $n$, alors elle contient les objets `L[i]` où `i` est un entier entre $0$ et $n-1$, alors que pour un dictionnaire `D`, l'ensemble des indices `i` tels que `D[i]` a un sens peut être arbitraire ou presque. On construit cet ensemble d'indices -- que l'on appelle les *clefs* du dictionnaire -- en même temps que `D` lui-même."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "D= {}                   # création d'un dictionnaire vide\n",
    "D[5]= \"bonjour\"         # 5 est maintenant une clef\n",
    "D[\"toto\"]= -1           # toto est maintenant une clef\n",
    "print(D)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "D[5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "[clef for clef in D]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "18 in D  # 18 est-il une clef?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Pour créer tout de suite un dictionnaire non-vide, on peut faire comme ceci :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "D= { (1,2,3) : \"du texte\", 7 : -4, \"a\" : \"b\"  }\n",
    "print(D)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notons que `(1,2,3)` a été utilisé comme clef. C'est un exemple de *tuple* (prononcé \"teupeul\", parfois traduit \"p-uplet\" en français). C'est presque la même chose qu'une liste (mais ce n'est pas une liste, notez les parenthèses au lieu des crochets). Nous ne voulons pas entrer dans les détails dans ce cours, donc nous retiendrons simplement ceci : un tuple se comporte comme une liste non-mutable (= non-modifiable). L'avantage des tuples sur les listes, c'est justement qu'on peut les utiliser comme clefs dans les dictionnaires! \n",
    "\n",
    "D'une manière générale, les clefs d'un dictionnaire ne doivent pas être mutables.\n",
    "\n",
    "Voici encore une autre syntaxe : `dict( (clef(x), valeur(x)) for x in (quelque chose) )`. Par exemple :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# dictionnaire des racines carrées d'entiers qui sont également des entiers :\n",
    "N= 10\n",
    "racines= dict(  (n**2, n) for n in range(N)   )   \n",
    "print(racines)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "racines[9]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Et il y a même une syntaxe spéciale dans le cas où toutes les clefs sont des chaînes de caractères (notons qu'aucune de ces syntaxes \"raccourcies\" n'est vraiment utile pour nous, dans nos exemples) :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "notes_au_TP= dict(kevin= 12, whitney= 6, robert= 10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "notes_au_TP"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ">**Exercice (Stirling 2)** Créer un dictionnaire `table_stirling` vide, puis une fonction `stirling2(n,k)` qui calcule $c(n,k)$ en stockant les résultats dans le dictionnaire au fur et à mesure, pour ne pas avoir à les re-calculer la prochaine fois qu'on appelle la fonction.\n",
    ">\n",
    ">Comparer la vitesse."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
